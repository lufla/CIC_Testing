#include <Arduino.h>
#include <SPI.h>
const int ADC_CS_PIN = 15;        // GPIO15 for MCS (ADC Chip Select)
const int IO_EXPANDER_CS_PIN = 5; // GPIO5 for CCS (I/O Expander Chip Select)

SPIClass spi(VSPI);

// MCP23S08 Registers and Commands
const byte MCP23S08_IODIR = 0x00;
const byte MCP23S08_IPOL = 0x01;
const byte MCP23S08_GPINTEN = 0x02;
const byte MCP23S08_DEFVAL = 0x03;
const byte MCP23S08_INTCON = 0x04;
const byte MCP23S08_IOCON = 0x05;
const byte MCP23S08_GPPU = 0x06;
const byte MCP23S08_INTF = 0x07;
const byte MCP23S08_INTCAP = 0x08;
const byte MCP23S08_GPIO = 0x09;
const byte MCP23S08_OLAT = 0x0A;

const byte MCP23S08_WRITE_OPCODE = 0x40; // R/W bit = 0
const byte MCP23S08_READ_OPCODE = 0x41;  // R/W bit = 1

// CS5523 Commands
const byte CS5523_CMD_RESET = 0x03;
const byte CS5523_CMD_CONV_SINGLE = 0x80;

// --- Function Prototypes ---
void setupSpi();
void setupIoExpander();
void setupAdc();
void setVcanVoltage(byte setting);
float readAdcVoltage(int channel);
byte readIoExpanderGpio();
void selectSpiDevice(int csPin);
void deselectSpiDevices();

// --- Setup Function ---
void setup() {
    Serial.begin(115200);
    while (!Serial);

    Serial.println("\n--- ESP32 VCAN & ADC On/Off Test ---");

    pinMode(ADC_CS_PIN, OUTPUT);
    pinMode(IO_EXPANDER_CS_PIN, OUTPUT);

    deselectSpiDevices();

    setupSpi();
    setupIoExpander();
    setupAdc();

    // --- Debug: check if ADC responds
    selectSpiDevice(ADC_CS_PIN);
    spi.beginTransaction(SPISettings(2000000, MSBFIRST, SPI_MODE0));
    byte echo = spi.transfer(0xFF); // send dummy
    spi.endTransaction();
    deselectSpiDevices();
    Serial.printf("ADC echo after reset: 0x%02X\n", echo);

    Serial.println("\n--- Starting Power Toggling Cycle ---");
}


// --- Main Loop ---
void loop() {
    byte vcan_on_setting = 0x03;  // GP0=1 (Power Enable), GP1=1 (Voltage Select)
    byte vcan_off_setting = 0x00; // GP0=0, GP1=0

    // --- Turn Power ON ---
    Serial.println("\n>>> Turning VCAN Power ON <<<");
    Serial.printf("Setting VCAN to 1.9V (Setting Byte: 0x%02X)\n", vcan_on_setting);
    setVcanVoltage(vcan_on_setting);
    delay(550); // Wait for command to process

    // --- VERIFY THE WRITE by reading back the register value ---
    byte gpio_status_on = readIoExpanderGpio();
    Serial.printf("  - Reading back GPIO register: 0x%02X\n", gpio_status_on);
    if (gpio_status_on == vcan_on_setting) {
        Serial.println("  - VERIFICATION SUCCESS: GPIO register is set correctly.");
    } else {
        Serial.println("  - VERIFICATION FAILED: GPIO register did NOT update!");
    }
    delay(400); // Wait for voltage to stabilize

    // Measure the voltage
    float vcanA_voltage_on = readAdcVoltage(1);
    float vcanB_voltage_on = readAdcVoltage(2);
    Serial.printf("  -> Measured VCAN A: %.3f V\n", vcanA_voltage_on);
    Serial.printf("  -> Measured VCAN B: %.3f V\n", vcanB_voltage_on);

    delay(2000);

    // --- Turn Power OFF ---
    Serial.println("\n<<< Turning VCAN Power OFF >>>");
    setVcanVoltage(vcan_off_setting);
    delay(500); // Wait for voltage to discharge

    // Measure the voltage again
    float vcanA_voltage_off = readAdcVoltage(1);
    float vcanB_voltage_off = readAdcVoltage(2);
    Serial.printf("  -> Measured VCAN A: %.3f V\n", vcanA_voltage_off);
    Serial.printf("  -> Measured VCAN B: %.3f V\n", vcanB_voltage_off);

    delay(2000);
}

void setupSpi() {
    spi.begin();
}

void setupIoExpander() {
    Serial.println("Configuring MCP23S08 I/O Expander...");
    selectSpiDevice(IO_EXPANDER_CS_PIN);
    spi.beginTransaction(SPISettings(1000000, MSBFIRST, SPI_MODE0));
    spi.transfer(MCP23S08_WRITE_OPCODE); // Opcode for write
    spi.transfer(MCP23S08_IOCON);        // IOCON register address (0x05)
    spi.transfer(0x08);                  // Value to set HAEN bit to 1
    spi.endTransaction();
    deselectSpiDevices();
    delay(1);

    // --- Transaction 2: Set all GPIO pins to be outputs ---
    selectSpiDevice(IO_EXPANDER_CS_PIN);
    spi.beginTransaction(SPISettings(1000000, MSBFIRST, SPI_MODE0));
    spi.transfer(MCP23S08_WRITE_OPCODE);
    spi.transfer(MCP23S08_IODIR); // IODIR register address (0x00)
    spi.transfer(0x00);           // Value for all outputs
    spi.endTransaction();
    deselectSpiDevices();
    delay(1);

    // --- Transaction 3: Set initial output state to LOW ---
    setVcanVoltage(0x00); // Use existing function to write 0x00 to GPIO register

    Serial.println("MCP23S08 configuration complete.");
}

void setupAdc() {
    selectSpiDevice(ADC_CS_PIN);
    spi.beginTransaction(SPISettings(2000000, MSBFIRST, SPI_MODE0));
    spi.transfer(CS5523_CMD_RESET); // only reset byte
    spi.endTransaction();
    deselectSpiDevices();
    delay(100); // allow ADC to reset
    Serial.println("CS5523 ADC reset complete.");
}

void setVcanVoltage(byte setting) {
    selectSpiDevice(IO_EXPANDER_CS_PIN);
    spi.beginTransaction(SPISettings(1000000, MSBFIRST, SPI_MODE0));
    spi.transfer(MCP23S08_WRITE_OPCODE);
    spi.transfer(MCP23S08_GPIO);
    spi.transfer(setting);
    spi.endTransaction();
    deselectSpiDevices();
}

/**
 * @brief Reads the GPIO register from the MCP23S08 to verify writes.
 * @return The 8-bit value of the GPIO register.
 */
byte readIoExpanderGpio() {
    byte gpio_value = 0;
    selectSpiDevice(IO_EXPANDER_CS_PIN);
    spi.beginTransaction(SPISettings(1000000, MSBFIRST, SPI_MODE0));
    spi.transfer(MCP23S08_READ_OPCODE); // Send READ opcode
    spi.transfer(MCP23S08_GPIO);        // Send register address to read
    gpio_value = spi.transfer(0x00);    // Send dummy byte to clock in the data
    spi.endTransaction();
    deselectSpiDevices();
    return gpio_value;
}

float readAdcVoltage(int channel) {
    if (channel < 1 || channel > 4) return -1.0;

    byte convCmd = CS5523_CMD_CONV_SINGLE | ((channel - 1) << 1);

    // Start conversion
    selectSpiDevice(ADC_CS_PIN);
    spi.beginTransaction(SPISettings(2000000, MSBFIRST, SPI_MODE0));
    spi.transfer(convCmd);
    spi.endTransaction();
    deselectSpiDevices();

    // Wait enough time (since DRDY not wired)
    delay(250);

    // Read conversion result
    long raw = 0;
    selectSpiDevice(ADC_CS_PIN);
    spi.beginTransaction(SPISettings(2000000, MSBFIRST, SPI_MODE0));
    spi.transfer(0x0C); // "Read Data" command
    raw  = ((long)spi.transfer(0x00) << 16);
    raw |= ((long)spi.transfer(0x00) << 8);
    raw |= ((long)spi.transfer(0x00));
    spi.endTransaction();
    deselectSpiDevices();

    // Sign-extend 24-bit
    if (raw & 0x800000) raw |= 0xFF000000;

    const float V_REF = 2.5;       // check if your board really uses 2.5 V ref
    const long MAX_ADC_VALUE = 8388607;
    float voltage = ((float)raw / MAX_ADC_VALUE) * V_REF;
    return voltage;
}


void selectSpiDevice(int csPin) {
    digitalWrite(IO_EXPANDER_CS_PIN, HIGH);
    digitalWrite(ADC_CS_PIN, HIGH);
    delayMicroseconds(5);
    digitalWrite(csPin, LOW);
    delayMicroseconds(5);
}

void deselectSpiDevices() {
    digitalWrite(IO_EXPANDER_CS_PIN, HIGH);
    digitalWrite(ADC_CS_PIN, HIGH);
    delayMicroseconds(5);
}

